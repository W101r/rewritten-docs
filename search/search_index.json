{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the W101r Docs","text":"<p>This library is for all developmental documentations of the Wizard101Rewritten project.</p> <p>Writings include technical explainations of game internals, as well as guided steps to how our emulator works in written form.</p>"},{"location":"#our-projects","title":"Our Projects","text":""},{"location":"#imlight","title":"Imlight","text":"<p>Imlight is the endgoal of W101r. It's intended to be the successor to Ravenwood (see below). It's primary goal is continuing the reverse engineering hurdles while simultaneously creating a practical, robust server. Each server is controlled by a series of nodes, each working in unison to emulate Kingsisle's backend service.</p> <p>You can view an overview of the architecture here.</p>"},{"location":"#ravenwood","title":"Ravenwood","text":"<p>Ravenwood is the elder of W101r. This is the progress shown in the announcements channel.</p> <p>Ravenwood now primarily serves as a research project with no intention of being the actual implementation of our final server.</p>"},{"location":"#mythos","title":"Mythos","text":"<p>When a rewrite was called for Ravenwood, Mythos was the answer. Still under core development, Mythos is an emulator rewritten in JavaScript. Due to the functionalities of JavaScript,  there was an obvious conflict between the dynamic nature of JS and the static types of C++, Wizard101's underlying language.</p> <p>Mythos now primarily serves as a practical code example of emulating Wizard101's backend system in a language other than C#.</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Contributions are welcome by Wizard101Rewritten developers only.</p> <p>We ask that contributors follow the main staples of contributions. Development should happen on branches, which are requested to main to be reviewed and pulled.</p> <p>Review proper branch naming conventions here.</p>"},{"location":"clientfiles/start/","title":"Start","text":"<p>This section serves as documentation for the usage of files found in the client directories.</p>"},{"location":"documentation/DML/dml-data-types/","title":"DML Data Types","text":"Name C++ Type Binary BYT int8_t Signed 1-byte integer. UBYT uint8_t Unsigned 1-byte integer. SHRT int16_t Signed 2-byte integer in little-endian byte order. USHRT uint16_t Unsigned 2-byte integer in little-endian byte order. INT int32_t Signed 4-byte integer in little-endian byte order. UINT uint32_t Unsigned 4-byte integer in little-endian byte order. STR uint8_t[] or char[] A length-prefixed string of bytes, with the length being a USHRT. WSTR uint16_t[] or char16_t[] A length-prefixed string of little-endian UTF-16 characters without the Byte Order Mark, with the length being a USHRT. FLT float IEEE-754 32-bit floating point integer in little-endian byte order. DBL double IEEE-754 64-bit floating point integer in little-endian byte order. GID uint64_t Unsigned 8-byte integer in little-endian byte order. <p>This table is from Joshsora's Libki.</p>"},{"location":"documentation/DML/dml-protocols/","title":"DML Protocols","text":"<p>Sharing</p> <p>Due to legality reasons, we ask that none of our developers upload these records to any repository. Keep them local only.</p> <p>A DML Protocol is a subsection of Kingisle's Networking Protocol. It serves to elaborate requests to in-game context, such as <code>HousingMessages</code>, or <code>LoginMessages</code>.</p>"},{"location":"documentation/DML/dml-protocols/#protocol-syntax","title":"Protocol Syntax","text":"<p>Kingisle stores these protocols locally, inside the <code>root.wad</code>. Each protocol can be represented as an XML file.</p> <p>The very first node included in every protocol is an XML metadata node, which states the XML version used for each file.</p> <p>The following and last base node will be named after the file. This is where the protocol records lie. The child nodes will contain the written template for any message relating to the protocol. These are called the protocol records. However, the very first record is an exception. It is instead replaced with a metadata node, labeled <code>_ProtocolInfo</code>.</p>"},{"location":"documentation/DML/dml-protocols/#protocol-info","title":"Protocol Info","text":"<p>The protocol information is sorted as the first child node, under a metadata node, labeled always as <code>_ProtocolInfo</code>.</p> <p>The ProtocolInfo node will always contain 4 elements:</p> Name Description ServiceID The unique ID of this protocol. ProtocolType A one-word descriptor for the protocol. ProtocolVersion The version of the protocol. ProtocolDescription A short summary of details of the protocol. <p>An example of the ProtocolInfo node: <pre><code>&lt;_ProtocolInfo&gt;\n&lt;RECORD&gt;\n&lt;ServiceID TYPE=\"UBYT\"&gt;5&lt;/ServiceID&gt;\n&lt;ProtocolType TYPE=\"STR\"&gt;GAME&lt;/ProtocolType&gt;\n&lt;ProtocolVersion TYPE=\"INT\"&gt;1&lt;/ProtocolVersion&gt;\n&lt;ProtocolDescription TYPE=\"STR\"&gt;Game Messages&lt;/ProtocolDescription&gt;\n&lt;/RECORD&gt;\n&lt;/_ProtocolInfo&gt;\n</code></pre></p>"},{"location":"documentation/DML/dml-protocols/#protocol-records","title":"Protocol Records","text":"<p>You can find further elaboration on protocol records under this section.</p> <p>Every node after the protocol information will be the written template for every message the client is capable of sending, and all of the replies expected from the related server.</p> <p>Each record will contain some amount of metadata, including the <code>_MsgOrder</code> for the given record. For whatever reason, Kingsisle does not include this metadata element for every protocol. If this is the case, the unique message ID for every record will be the order in which those elements appear ordinally.</p>"},{"location":"documentation/DML/dml-protocols/#finding-the-protocols","title":"Finding the Protocols","text":"<p>In Wizard101's case, the DML protocols are stored in the <code>root.wad</code> found under the <code>GameData</code> directory. Using an external tool, we can unpack the <code>.wad</code> files.</p> <p>Unpacking</p> <p>Unpacking the <code>root.wad</code> will take many moments! Give it some time.</p> <p>Once finally unpacked, we are introduced to a multitude of uncompressed data. We can further elaborate the search by searching for <code>*Messages.xml</code>.</p>"},{"location":"documentation/DML/dml-records/","title":"DML Records","text":"<p>Sharing</p> <p>Due to legality reasons, we ask that none of our developers upload these records to any repository. Keep them local only.</p> <p>DML records serve as a written template for each of the requests the client is capable of sending, and all the expected replies from the server.</p> <p>These records can be found in Wizard101's internals, and each record can be represented as XML. Every record must fall under a protocol.</p>"},{"location":"documentation/DML/dml-records/#dml-syntax","title":"DML Syntax","text":"<p>Each DML record starts as an XML node named as a short keyword or phrase, prefixed by <code>MSG_[...]</code>. The record is then elaborated with a single child node, named <code>RECORD</code>.</p> <p>The <code>RECORD</code> node holds the child nodes exclusive to the DML record. These are labeled as DML elements. </p>"},{"location":"documentation/DML/dml-records/#dml-elements","title":"DML Elements","text":"<p>An example of a DML element: <pre><code>&lt;UserID TYPE=\"GID\" [NOXFER=\"TRUE\"]&gt;&lt;/UserID&gt;\n</code></pre> Each DML element begins with a camel cased identifier. Each element must contain an attribute of <code>TYPE=[...]</code>, signifying the data type used for serialization/deserialization purposes. </p> <p>You can view the table for DML element types here.</p> <p>Optionally included is the <code>NOXFER</code> (no-transfer) attribute, signifying metadata nodes that are not included in serialization.</p>"},{"location":"documentation/DML/dml-records/#dml-metadata","title":"DML Metadata","text":"<p>Each record holds an amount of metadata node, noted by the first character being an underscore (<code>_</code>), and further clarified with a <code>NOXFER</code> attribute. These elements will always appear first in a record.</p> Name Type Always Appears Description _MsgOrder UBYT No Used during deserialization to determine the message type. _MsgName STR Yes The name of the message. _MsgDescription STR Yes A quick summary on what this message is for. _MsgHandler STR Yes Used internally to determine what method handler should be called upon receiving this message. _MsgAccessLvl UBYT No Used internally to determine that a client has sufficient permission to call this message. <p>LoginMessages.xml<pre><code>&lt;MSG_CREATECHARACTERRESPONSE&gt;\n&lt;RECORD&gt;\n&lt;_MsgOrder TYPE=\"UBYT\" NOXFER=\"TRUE\"&gt;5&lt;/_MsgOrder&gt;\n&lt;_MsgName TYPE=\"STR\" NOXFER=\"TRUE\"&gt;MSG_CREATECHARACTERRESPONSE&lt;/_MsgName&gt;\n&lt;_MsgDescription TYPE=\"STR\" NOXFER=\"TRUE\"&gt;Server sends this when character creation is completed.&lt;/_MsgDescription&gt;\n&lt;_MsgHandler TYPE=\"STR\" NOXFER=\"TRUE\"&gt;MSG_CreateCharacterResponse&lt;/_MsgHandler&gt;\n&lt;ErrorCode TYPE=\"INT\"&gt;&lt;/ErrorCode&gt;\n&lt;/RECORD&gt;\n&lt;/MSG_CREATECHARACTERRESPONSE&gt;\n</code></pre> These DML elements are not serialized, and serve no other purpose than developer documentation.</p> <p>If the <code>_MsgAccessLvl</code> does not appear, it's safe to assume that a client with any authority is capable.</p> <p>For whatever reason, Kingsisle does not include the <code>_MsgOrder</code> metadata element for every protocol. If this is the case, the unique message ID for every record will be the order in which those records appear ordinally.</p>"},{"location":"documentation/DML/dml-records/#dml-record-example","title":"DML Record Example","text":"<p>An example of a DML record: GameMessages.xml<pre><code>&lt;MSG_ATTACH&gt;\n&lt;RECORD&gt;\n&lt;_MsgName TYPE=\"STR\" NOXFER=\"TRUE\"&gt;MSG_ATTACH&lt;/_MsgName&gt;\n&lt;_MsgDescription TYPE=\"STR\" NOXFER=\"TRUE\"&gt;Attach a socket to a game object.&lt;/_MsgDescription&gt;\n&lt;_MsgHandler TYPE=\"STR\" NOXFER=\"TRUE\"&gt;MSG_Attach&lt;/_MsgHandler&gt;\n&lt;_MsgAccessLvl TYPE=\"UBYT\" NOXFER=\"TRUE\"&gt;1&lt;/_MsgAccessLvl&gt;\n&lt;GameObjectID TYPE=\"GID\"&gt;&lt;/GameObjectID&gt;\n&lt;LoginKey TYPE=\"STR\"&gt;&lt;/LoginKey&gt;\n&lt;UserID TYPE=\"GID\"&gt;&lt;/UserID&gt;\n&lt;CharID TYPE=\"GID\"&gt;&lt;/CharID&gt;\n&lt;ZoneName TYPE=\"STR\"&gt;&lt;/ZoneName&gt;\n&lt;Location TYPE=\"STR\"&gt;&lt;/Location&gt;\n&lt;TargetPlayerID TYPE=\"GID\"&gt;&lt;/TargetPlayerID&gt;\n&lt;ZoneID TYPE=\"GID\"&gt;&lt;/ZoneID&gt;\n&lt;Slot TYPE=\"INT\"&gt;&lt;/Slot&gt;\n&lt;SessionID TYPE=\"GID\"&gt;&lt;/SessionID&gt;\n&lt;SessionSlot TYPE=\"INT\"&gt;&lt;/SessionSlot&gt;\n&lt;PassKey TYPE=\"STR\"&gt;&lt;/PassKey&gt;\n&lt;Reattach TYPE=\"UBYT\"&gt;&lt;/Reattach&gt;\n&lt;Retry TYPE=\"UBYT\"&gt;&lt;/Retry&gt;\n&lt;Locale TYPE=\"STR\"&gt;&lt;/Locale&gt;\n&lt;/RECORD&gt;\n&lt;/MSG_ATTACH&gt;\n</code></pre></p>"},{"location":"documentation/DML/dml/","title":"What is DML?","text":"<p>DML or Data Markup Language is the structure format used for data serialization in Wizard101 and it's relevant systems. This system allows the client to quickly instantiate a new, context specific request from hard-coded templates to then send to a service.</p>"},{"location":"documentation/KINP/getting-packets/","title":"Sniffing Packets","text":""},{"location":"documentation/KINP/getting-packets/#quick-start","title":"Quick Start","text":""},{"location":"documentation/KINP/getting-packets/#sniffing-packets","title":"Sniffing Packets","text":"<p>A packet is a set of bytes sent to or from the server. Kingsisle sends these packets via TCP, and every packet containing Kingsisle's signature will hereby by refered to as a magic packet.</p> <p>You can easily view these packets via WireShark (or any relevant tool) using a capture filter: <pre><code>(src net 165.193.0.0/16 or dst net 165.193.0.0/16) and greater 61\n</code></pre></p> <p>Common PC softwares can interfere with our capture filter. You can further elaborate by adding additional ports: <pre><code>tcp.port == 12000 || tcp.port == 12170 || tcp.port == 59384 || tcp.port == 57443 || tcp.port == 59359 || udp.port == 12171\n</code></pre></p>"},{"location":"documentation/KINP/kinp/","title":"Networking Protocol","text":"<p>Kingsisle does not use an unfamiliar system found in MMO titles. Every client sends a message corresponding to an action rapidly to the server. The server calculations based on the received data, and approves or denies the request.</p> <p>Kingisle's implementation of such system is labeled as KingsIsle Networking Protocol, or (KINP).</p>"},{"location":"documentation/KINP/packet-framing/","title":"Packet Framing","text":"<p>This page serves as a general overview of Kingsisle's packet framing used in Wizard101.</p> <p>Assume that every byte sequence will be in little-endian order unless otherwise stated.</p>"},{"location":"documentation/KINP/packet-framing/#magic-header","title":"Magic Header","text":"<p>Each magic packet starts with a 2-byte sequence in little-endian byte order: <code>0xF00D</code>. This is referred to as the start signal.</p> <p>Following the start signal is another 2-byte sequence in little-endian byte order. This signifies the length of the following message. If the length of the following body is larger than the limits of a <code>uint16_t</code>, or <code>0x7FFF</code>, the magic header will change:</p>"},{"location":"documentation/KINP/packet-framing/#small-header","title":"Small Header","text":"Name Type Description Start Signal uint16_t Always <code>0xF00D</code>. Indicates the start of a message. length uint16_t The length of the following body."},{"location":"documentation/KINP/packet-framing/#large-header","title":"Large Header","text":"Name Type Description Start Signal uint16_t Always <code>0xF00D</code>. Indicates the start of a message. length uint16_t Constant <code>0x8000</code> bigLength uint32_t The actual length of the following body."},{"location":"documentation/KINP/packet-framing/#body","title":"Body","text":"<p>Starting the body off is the body header. This header forks the payload into two separate types of messages: control and data.</p> Name Type Description isControl bool Indicates whether this packet is a control message or DML message. opCode uint8 Determines the operation code for a control message. padding uint16 Padding between the body header and payload. payload uint8[] The following payload."},{"location":"documentation/KINP/packet-framing/#payload","title":"Payload","text":"<p>At this point, it's recommended that you become familiar with the Data Management Layer first.</p> <p>If the body header indicates this payload will be a control message, then the corresponding binary buffer will begin here.</p> <p>On the contrary, a data message will continue with a secondary header indicating the DML protocol and DML record.</p> Name Type Description svcid uint8 The service ID of the payload; this equates to the DML protocol ID. msgid uint8 The message ID of the payload, relative to the protocol. length uint16 Indicates the length of the payload, including this header. payload uint8[] The following data payload."},{"location":"documentation/ObjectProperty/ObjectManager/","title":"ObjectManager","text":""},{"location":"documentation/ObjectProperty/ObjectManager/#oid","title":"OID","text":"<p>An object identifier (OID) is an extensively used identification mechanism jointly developed by ITU-T and ISO/IEC for naming any type of object, concept or \"thing\" with a globally unambiguous name which requires a persistent name (long life-time). It is not intended to be used for transient naming. OIDs, once allocated, should not be re-used for a different object/thing.</p> <p>Each <code>PropertyClass</code> and respective <code>Property</code> contains a uniquely created hash to serve as an identifier for deserializing of ObjectProperty. The OID for each object is generated at runtime using a homebrew algorithm.</p>"},{"location":"documentation/ObjectProperty/ObjectManager/#weak-oid","title":"Weak OID","text":"<p>The ObjectManager also contains an allocation method for generating a weak OID. It's currently unclear as to what defines an OID as \"weak\".</p>"},{"location":"documentation/ObjectProperty/ObjectProperty/","title":"ObjectProperty","text":"<p>With as much traffic as the data management layer handles, it's impossible to fully acknowledge the complex data types of C++. Kingsisle uses an internal system labeled as <code>ObjectProperty</code> to handle such cases.</p> <p>In some cases, a DML record will contain an unsuspecting string which actually represents the serialized binary buffer of an internal C++ type. For future reference, we shall label these strings as a <code>ByteString</code>.</p>"},{"location":"documentation/ObjectProperty/PropertyClass/","title":"PropertyClass","text":"<p>Warning</p> <p>The following information is still being reverse engineered. Take as a general idea instead of practical documenatation.</p>"},{"location":"documentation/ObjectProperty/PropertyClass/#propertyclass","title":"PropertyClass","text":"<p><code>PropertyClass</code> is an abstract type used to signify which internal complex types are capable of being subjected to binary serialization. Each field of the following class will contain another nested attribute, labeled simply as <code>Property</code>. A major (possibly only) usage case for Property Classes is for communication through the data management layer.</p>"},{"location":"documentation/ObjectProperty/PropertyClass/#property","title":"Property","text":"<p>Each field of the PropertyClass contains an attribute known simply as <code>Property</code>. This serves as specific field elaboration to the binary serialization process with relevant information. </p> <p>Each property class contains the minimum set of information needed for serialization in the repesentation of two more classes: <code>Type</code> and <code>Value</code>.</p>"},{"location":"documentation/ObjectProperty/PropertyClass/#type","title":"Type","text":"<p>The <code>Type</code> class (or enum?) serves as a handler for the property's largest concern as a C++ field: it's memory footprint. This list is separate from the DML data types.</p>"},{"location":"documentation/ObjectProperty/PropertyClass/#value","title":"Value","text":"<p>Still unclear, but pretty self-explainatory from the name.</p>"},{"location":"documentation/ObjectProperty/PropertyClass/#serialization","title":"Serialization","text":""},{"location":"documentation/ObjectProperty/PropertyClass/#finding-property-classes","title":"Finding Property Classes","text":"<p>Finding these property classes is trivial. Simply pass a launch argument <code>-x</code> with a following file name (which you can represent as a <code>.xml</code>) to the <code>WizardGraphicalClient.exe</code>. However, this dump does not include their hash. You may use WizWalker's type dump tool for a more verbose dump of the PropertyClasses and their respective hashes.</p>"},{"location":"imlight/imlight/","title":"Imlight","text":"<p>Imlight is a private server emulation project by the Wizard101Rewritten community.</p> <p>You can view the overview of server architecture here.</p>"},{"location":"imlight/imlight/#quick-start","title":"Quick Start","text":"<p>Todo</p> <p>This should be expanded into subsections soon.</p> <p>Imlight requires pre-generation of two internal systems in order to function properly.</p> <ol> <li>KiNP Records</li> <li>Property Classes</li> </ol> <p>You can review in detail what these systems entail for KiNP Records and Property Classes.</p> <p>The input needed for these systems can be found internally in Wizard101. Use the Wizard101 revision you'd like Imlight to run on.</p>"},{"location":"imlight/imlight/#kinp-records","title":"KiNP Records","text":"<p>Todo</p> <p>Expand on this by creating a WAD article and explaining the file format.</p> <p>This is the more difficult of the two sections. These files can be found in the <code>root.wad</code> of the game directory. However, these <code>.wad</code> files are packed and compressed and require external tooling to unravel. You can use [LINK HERE] to do exactly this.</p> <p>Once unpacked, search for <code>*Messages.xml</code>. All files found are required by Imlight.</p> <p>Copy these files into the <code>Imlight.Generator [input/records/]</code> directory.</p>"},{"location":"imlight/imlight/#property-classes","title":"Property Classes","text":"<p>You can easily dump the property classes as <code>.xml</code> representation by handing launch arguments to Wizard101's executable.</p> <p>In your <code>Wizard101/bin/</code> directory: <pre><code>WizardGraphicalClient.exe -x PropertyClassDump.xml\n</code></pre> You'll find the output in the same directory. Copy this file to the <code>Imlight.Generator [input/]</code> directory.</p>"}]}